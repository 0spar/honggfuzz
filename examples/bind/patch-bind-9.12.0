diff -Nur orig.bind-9.12.0/bin/named/fuzz.c bind-9.12.0/bin/named/fuzz.c
--- orig.bind-9.12.0/bin/named/fuzz.c	2018-01-29 20:56:59.219539378 +0100
+++ bind-9.12.0/bin/named/fuzz.c	2018-01-29 21:12:55.021888068 +0100
@@ -30,10 +30,6 @@
 #include <unistd.h>
 #include <pthread.h>
 
-#ifndef __AFL_LOOP
-#error To use American Fuzzy Lop you have to set CC to afl-clang-fast!!!
-#endif
-
 /*
  * We are using pthreads directly because we might be using it with
  * unthreaded version of BIND, where all thread functions are
@@ -586,7 +582,6 @@
 	 * this signature ("##SIG_AFL_PERSISTENT##") and runs the binary
 	 * in persistent mode if it's present.
 	 */
-	__AFL_LOOP(0);
 
 	return (NULL);
 }
@@ -750,7 +745,6 @@
 void
 named_fuzz_setup(void) {
 #ifdef ENABLE_AFL
-	if (getenv("__AFL_PERSISTENT") || getenv("AFL_CMIN")) {
 		pthread_t thread;
 		void *(fn) = NULL;
 
@@ -776,6 +770,5 @@
 		RUNTIME_CHECK(pthread_mutex_init(&mutex, NULL) == 0);
 		RUNTIME_CHECK(pthread_cond_init(&cond, NULL) == 0);
 		RUNTIME_CHECK(pthread_create(&thread, NULL, fn, NULL) == 0);
-	}
 #endif /* ENABLE_AFL */
 }
diff -Nur orig.bind-9.12.0/bin/named/main.c bind-9.12.0/bin/named/main.c
--- orig.bind-9.12.0/bin/named/main.c	2018-01-29 20:56:59.223539303 +0100
+++ bind-9.12.0/bin/named/main.c	2018-01-29 21:12:50.917963609 +0100
@@ -1347,10 +1347,249 @@
 }
 #endif /* HAVE_LIBSCF */
 
+#include <arpa/inet.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <net/if.h>
+#include <net/route.h>
+#include <netinet/ip6.h>
+#include <netinet/tcp.h>
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <sys/uio.h>
+
+#include <sched.h>
+#include <libhfuzz/libhfuzz.h>
+
+static void unsh(void)
+{
+	if (linuxEnterNs(CLONE_NEWUSER|CLONE_NEWNET|CLONE_NEWNS) == false) {
+			exit(1);
+	}
+	if (linuxIfaceUp("lo") == false) {
+			exit(1);
+	}
+	if (linuxMountTmpfs("/tmp") == false) {
+			exit(1);
+	}
+}
+
+#include <pthread.h>
+static size_t rlen = 0;
+static const uint8_t *rbuf = NULL;
+
+__attribute__ ((no_sanitize("memory")))
+__attribute__ ((no_sanitize("address")))
+static void *GETDATA(void *unused __attribute__((used)))
+{
+    int myfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+    if (myfd == -1) {
+        perror("socket");
+        exit(1);
+    }
+	int val = 1;
+	if (setsockopt(myfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) == -1) {
+		perror("setsockopt(SO_REUSEADDR)");
+	}
+
+    struct sockaddr_in saddr;
+    saddr.sin_family = AF_INET;
+    saddr.sin_port = htons(53);
+    saddr.sin_addr.s_addr = inet_addr("127.0.0.2");
+    if (bind(myfd, &saddr, sizeof(saddr)) == -1) {
+        perror("bind");
+        exit(1);
+    }
+
+    if (listen(myfd, SOMAXCONN) == -1) {
+        perror("listen");
+        exit(1);
+    }
+
+    for (;;) {
+        struct sockaddr_in cli;
+        socklen_t cli_len = sizeof(cli);
+
+        int nfd = accept(myfd, &cli, &cli_len);
+        if (nfd == -1) {
+            perror("accept");
+            exit(1);
+        }
+
+        static char b[1024 * 1024];
+        ssize_t sz = recv(nfd, b, sizeof(b), 0);
+        if (sz <= 0) {
+            perror("recv");
+            _exit(1);
+        }
+        if (sz < 4) {
+            close(nfd);
+            continue;
+        }
+
+		uint16_t t_l = htons(rlen + 2);
+		const struct iovec iov[] = {
+			{
+					.iov_base = &t_l,
+					.iov_len = sizeof(t_l),
+			},
+			{
+					.iov_base = &b[2],
+					.iov_len = 2,
+			},
+			{
+					.iov_base = rbuf,
+					.iov_len = rlen,
+			},
+		};
+	
+		if (writev(nfd, iov, 3) == -1) {
+            perror("writev() failed");
+        }
+	
+        close(nfd);
+    }
+
+    return NULL;
+}
+
+static void rndloop(int sock) {
+    const struct sockaddr_in bsaddr = {
+        .sin_family = AF_INET,
+        .sin_port = htons(0),
+        .sin_addr.s_addr = htonl((((uint32_t)util_rnd64()) & 0x00FFFFFF) | 0x7F000000),
+    };
+    if (bind(sock, (struct sockaddr *)&bsaddr, sizeof(bsaddr)) == -1) {
+		perror("bind");
+    }
+}
+
+__attribute__ ((no_sanitize("memory")))
+__attribute__ ((no_sanitize("address")))
+static void *SENDREQ(void *unused __attribute__((used)))
+{
+    usleep(500000);
+
+    for (;;) {
+        int myfd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+        if (myfd == -1) {
+            perror("socket");
+            exit(1);
+        }
+		int val = 1;
+		if (setsockopt(myfd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val)) == -1) {
+			perror("setsockopt(SO_REUSEADDR)");
+		}
+
+		rndloop(myfd);
+
+        struct sockaddr_in saddr;
+        saddr.sin_family = AF_INET;
+        saddr.sin_port = htons(53);
+        saddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+        if (connect(myfd, &saddr, sizeof(saddr)) == -1) {
+            close(myfd);
+            continue;
+        }
+
+        const uint8_t *buf;
+        size_t len;
+        HF_ITER(&buf, &len);
+
+        rlen = 0;
+        rbuf = NULL;
+
+        if (len < 32) {
+            close(myfd);
+            continue;
+        }
+
+        uint32_t tmplen = *((const uint32_t *) buf);
+
+        buf = &buf[sizeof(uint32_t)];
+        len -= sizeof(uint32_t);
+
+        tmplen %= len;
+
+        rbuf = &buf[tmplen];
+        rlen = len - tmplen;
+        len = tmplen;
+
+		uint16_t t_l = htons(len);
+		const struct iovec iov[] = {
+			{
+					.iov_base = &t_l,
+					.iov_len = sizeof(t_l),
+			},
+			{
+					.iov_base = buf,
+					.iov_len = len,
+			},
+		};
+
+        if (writev(myfd, iov, 2) == -1) {
+       		perror("write");
+			close(myfd);
+			continue;
+        }
+
+        if (shutdown(myfd, SHUT_WR) == -1) {
+	       if (errno == ENOTCONN) {
+		       close(myfd);
+		       continue;
+	       }
+	       perror("shutdown");
+		   _exit(1);
+	    }
+
+       	uint8_t b[1024 * 512];
+       	while (recv(myfd, b, sizeof(b), 0) > 0);
+        close(myfd);
+    }
+}
+
+static void LAUNCHTHR(void)
+{
+    usleep(100000);
+
+    pthread_attr_t attr;
+    pthread_attr_init(&attr);
+    pthread_attr_setstacksize(&attr, 1024 * 1024 * 4);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+    pthread_t t;
+    if (pthread_create(&t, &attr, GETDATA, NULL) < 0) {
+        perror("pthread_create(LAUNCHTHR)");
+        exit(1);
+    }
+
+    usleep(300000);
+
+    pthread_attr_init(&attr);
+    pthread_attr_setstacksize(&attr, 1024 * 1024 * 4);
+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+    if (pthread_create(&t, &attr, SENDREQ, NULL) < 0) {
+        perror("pthread_create(SENDREQ)");
+        exit(1);
+    }
+}
+
 /* main entry point, possibly hooked */
 
 int
 main(int argc, char *argv[]) {
+	
+		if (getenv("NO_FUZZ") == NULL) {
+    		unsh();
+    		LAUNCHTHR();
+		}
+
 	isc_result_t result;
 #ifdef HAVE_LIBSCF
 	char *instance = NULL;
@@ -1402,7 +1641,7 @@
 
 	parse_command_line(argc, argv);
 
-#ifdef ENABLE_AFL
+#if 0
 	if (named_g_fuzz_type != isc_fuzz_none) {
 		named_fuzz_setup();
 	}
diff -Nur orig.bind-9.12.0/compile.sh bind-9.12.0/compile.sh
--- orig.bind-9.12.0/compile.sh	1970-01-01 01:00:00.000000000 +0100
+++ bind-9.12.0/compile.sh	2018-01-29 21:12:50.917963609 +0100
@@ -0,0 +1,8 @@
+#!/bin/sh
+
+set -ex
+
+CC=/home/jagger/src/honggfuzz/hfuzz_cc/hfuzz-clang CXX=/home/jagger/src/honggfuzz/hfuzz_cc/hfuzz-clang++ CFLAGS="-fsanitize=address -Wno-logical-not-parentheses -Wno-shift-negative-value -Wno-logical-not-parentheses -g -ggdb -O3" ./configure --prefix=/home/jagger/fuzz/bind/dist/ --disable-threads --without-gssapi --disable-chroot --disable-linux-caps --disable-seccomp --without-libtool --enable-ipv6 --enable-atomic --enable-epoll --with-openssl=no --enable-afl
+
+make clean
+make -j$(nproc)
diff -Nur orig.bind-9.12.0/lib/dns/cache.c bind-9.12.0/lib/dns/cache.c
--- orig.bind-9.12.0/lib/dns/cache.c	2018-01-29 20:56:59.291538040 +0100
+++ bind-9.12.0/lib/dns/cache.c	2018-01-29 21:12:50.921963536 +0100
@@ -46,7 +46,7 @@
  * DNS_CACHE_MINSIZE is how many bytes is the floor for dns_cache_setcachesize().
  * See also DNS_CACHE_CLEANERINCREMENT
  */
-#define DNS_CACHE_MINSIZE	2097152U /*%< Bytes.  2097152 = 2 MB */
+#define DNS_CACHE_MINSIZE	1U /*%< Bytes.  2097152 = 2 MB */
 /*!
  * Control incremental cleaning.
  * CLEANERINCREMENT is how many nodes are examined in one pass.
@@ -1050,8 +1050,8 @@
 	 * Impose a minimum cache size; pathological things happen if there
 	 * is too little room.
 	 */
-	if (size != 0U && size < DNS_CACHE_MINSIZE)
-		size = DNS_CACHE_MINSIZE;
+//	if (size != 0U && size < DNS_CACHE_MINSIZE)
+//		size = DNS_CACHE_MINSIZE;
 
 	LOCK(&cache->lock);
 	cache->size = size;
diff -Nur orig.bind-9.12.0/lib/dns/request.c bind-9.12.0/lib/dns/request.c
--- orig.bind-9.12.0/lib/dns/request.c	2018-01-29 20:56:59.299537891 +0100
+++ bind-9.12.0/lib/dns/request.c	2018-01-29 21:12:50.921963536 +0100
@@ -814,8 +814,9 @@
 		goto cleanup;
 	}
 
-	if ((options & DNS_REQUESTOPT_TCP) != 0 || r.length > 512)
+	if ((options & DNS_REQUESTOPT_TCP) != 0 || r.length >= 512)
 		tcp = ISC_TRUE;
+	tcp = ISC_TRUE;
 	share = ISC_TF((options & DNS_REQUESTOPT_SHARE) != 0);
 
  again:
@@ -1145,6 +1146,8 @@
 req_render(dns_message_t *message, isc_buffer_t **bufferp,
 	   unsigned int options, isc_mem_t *mctx)
 {
+		options |= DNS_REQUESTOPT_TCP;
+
 	isc_buffer_t *buf1 = NULL;
 	isc_buffer_t *buf2 = NULL;
 	isc_result_t result;
@@ -1201,9 +1204,10 @@
 	 * Copy rendered message to exact sized buffer.
 	 */
 	isc_buffer_usedregion(buf1, &r);
+	options |= DNS_REQUESTOPT_TCP;
 	if ((options & DNS_REQUESTOPT_TCP) != 0) {
 		tcp = ISC_TRUE;
-	} else if (r.length > 512) {
+	} else if (r.length >= 512) {
 		result = DNS_R_USETCP;
 		goto cleanup;
 	}
diff -Nur orig.bind-9.12.0/lib/dns/resolver.c bind-9.12.0/lib/dns/resolver.c
--- orig.bind-9.12.0/lib/dns/resolver.c	2018-01-29 20:56:59.299537891 +0100
+++ bind-9.12.0/lib/dns/resolver.c	2018-01-29 21:12:50.921963536 +0100
@@ -1884,6 +1884,7 @@
 	}
 	query->mctx = fctx->mctx;
 	query->options = options;
+	query->options = options | DNS_FETCHOPT_TCP;
 	query->attributes = 0;
 	query->sends = 0;
 	query->connects = 0;
diff -Nur orig.bind-9.12.0/lib/isc/random.c bind-9.12.0/lib/isc/random.c
--- orig.bind-9.12.0/lib/isc/random.c	2018-01-29 20:56:59.307537743 +0100
+++ bind-9.12.0/lib/isc/random.c	2018-01-29 21:12:50.921963536 +0100
@@ -127,12 +127,17 @@
 #endif
 }
 
+static isc_uint32_t RND = 1;
+
 void
 isc_random_get(isc_uint32_t *val) {
 	REQUIRE(val != NULL);
 
 	initialize();
 
+	*val = RND;
+	return;
+
 #ifndef HAVE_ARC4RANDOM
 	/*
 	 * rand()'s lower bits are not random.
@@ -375,6 +380,11 @@
 	REQUIRE(VALID_RNG(rng));
 	REQUIRE(output != NULL && length > 0);
 
+	for (size_t i = 0; i < length; i++) {
+			ptr[i] = i;
+	}
+	return;
+
 	LOCK(&rng->lock);
 
 	while (ISC_UNLIKELY(length > CHACHA_MAXLENGTH)) {
@@ -412,6 +422,8 @@
 	if (upper_bound < 2)
 		return (0);
 
+	return RND % upper_bound;
+
 	/*
 	 * Ensure the range of random numbers [min, 0xffff] be a multiple of
 	 * upper_bound and contain at least a half of the 16 bit range.
